## Reflection

### 1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?
Unary is a straightforward one-request-one-response interaction, which is similar to a traditional function call or REST API. This is good for operations like user authentication or simple data retrieval. Server streaming allows the client to send a single request while the server responds with a stream of messages. This is helpful for receiving progressive updates, downloading large datasets, and getting logs. Bi-directional streaming opens a two-way communication channel where both the client and server can continuously send and receive messages independently. This makes it  ideal for real-time applications like chat services or collaborative tools. 

### 2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?
Authentication involves verifying who's making the request, which is often handled through mechanisms such as JWT tokens passed in metadata or mutual TLS (mTLS) certificates. These two require careful validation to prevent unauthorized access. Authorization determines what the authenticated user is allowed to do, which may involve role-based access controls or policy checks implemented within interceptors. Data encryption for gRPC relies on HTTP/2. This means TLS needs to be properly configured to protect data in transit from eavesdropping or tampering. 

### 3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?
A potential challenge is the order of the message. This occurs due to bi-di streams, which does not guarantee strict sequencing, especially  when messages are sent from both ends simultaneously. Another potential challenge is is concurrancy, where each user's chat sessions may become an async task if the chat service scales to handle many users. 

### 4. What are the advantages and disa advantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?
An advantage is built-in flow control from the underlying mpsc channel, which helps avoiding overloading memory. Another advantage is it easily bridges async channels. The ReseciverStream takes tokio::mpsc::Receiver and changes it to something that implements the Stream trait. 
A disadvantage is an extra buffer later. A slight latency or memory overhead might occur since ReceiverStream and mpsc adds a memory buffer between the business logic and wire. Another disadvantage is how ReceiverStream abstracts away some lower-level stream behaviors.

### 5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?
Separating each service implementation into its own module or file is a way to reuse, modularity, and long-term maintainability. This keeps related logic together and avoiding a monolithic main file. Another way is to place shared types  in a centralized types or common module to prevent duplication across services. Other than that, isoisolating the core business logic from the gRPC-specific code maintain structure. By doing so, business functions can be tested independently of the network layer.

### 6. In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?
Recording each payment transaction to a database for record keeping is a step. This will help in  a transaction so failures donâ€™t leave partial writes. Another step is security check, to authenticate the user_id against a JWT or session. Another way is to add structured logging for payment attempts, which includes trace IDs or request IDs to trace issues across services. 

### 7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?
An impact is how adopting gRPC as a communication protocol introduces a schema-driven, strongly-typed approach that shapes the architecture of distributed systems, which is done by enforcing stricter contracts between services through Protocol Buffers. By doing so, it improves consistency and reliability in communication. However, it can make interoperability with other technologies more challenging, such as systems that does not fully have native gRPC support or systems that rely on JSON. gRPC uses HTTP/2 and binary serialization, it offers better performance and streaming capabilities compared to traditional REST APIs. Though additional tooling for debugging, monitoring, and protocol translation is required when interacting with older systems or languages with limited gRPC support.

### 8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?
An advantage is binary framing, which improves parsing efficienct at scale. This is because the messages are transmitted as binary frames instead of plain text. Another advantage is how it ables bidirectional streaming at the protocol level without having to do extra workarounds. 
A disadvantage is how not all proxies,  load balancers, or middleboxes fully support HTTP/2, which might require additional configuration or upgrades. Another disadvantage is how it's not always supported in browsers since direct HTTP/2 API calls from JavaScript.

### 9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?
The difference is how REST API and gRPC handle real-time communication and responsiveness. In REST APIs, every interaction follows a simple one-request-one-response pattern, which means every interaction follows a simple one-request-one-response pattern. If updates are needed continuously, the client will have to keep polling the server, and this adds unnecessary network traffic and latency. Whereas for gRPC, its bidirectional streaming opens a constant connection over HTTP/2. This allows both client and server to send messages freely, and independently over the same stream without waiting for a new request. 

### 10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?
The schema-based approach of gRPC, using Protocol Buffers, introduces both clarity and rigidity compared to the more flexible, schema-less nature of JSON in REST APIs. gRPC ensures that all data exchanged between client and server follows a strict contract by defining messages and services upfront in .proto files. This reduces misunderstandings and catching errors early through code generation. Other than that, this leads to stronger type safety and more efficient, compact binary serialization, which improves performance. On the other hand, JSON offers greater flexibility, letting developers adjust or extend payloads more freely without breaking consumers. However,  the cost of weaker typing, larger payload sizes, and more room for runtime errors may occur. 